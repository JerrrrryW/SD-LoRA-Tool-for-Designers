
import React, { useState } from 'react';
import axios from 'axios';
import {
  Container,
  Typography,
  Card,
  CardContent,
  Button,
  TextField,
  Box,
  CircularProgress,
  Snackbar,
  Alert,
  Paper,
} from '@mui/material';

const InferencePage: React.FC = () => {
  const [prompt, setPrompt] = useState('');
  const [negativePrompt, setNegativePrompt] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedImage, setGeneratedImage] = useState<string | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' } | null>(null);

  const handleGenerateImage = async () => {
    if (!prompt) {
      setSnackbar({ open: true, message: 'Please enter a prompt.', severity: 'error' });
      return;
    }

    setIsGenerating(true);
    setGeneratedImage(null);

    try {
      const response = await axios.post(
        'http://localhost:8000/generate',
        {
          prompt,
          negative_prompt: negativePrompt,
        },
        {
          responseType: 'blob',
        }
      );

      const imageUrl = URL.createObjectURL(response.data);
      setGeneratedImage(imageUrl);
      setSnackbar({ open: true, message: 'Image generated successfully!', severity: 'success' });
    } catch (error) {      
      let message = 'An unknown error occurred.';
      if (axios.isAxiosError(error) && error.response) {
        // Since the response is a blob, we need to read it as text
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const errorData = JSON.parse(reader.result as string);
            message = errorData.detail || 'Failed to generate image.';
          } catch (e) {
            message = 'Failed to parse error response.';
          }
          setSnackbar({ open: true, message, severity: 'error' });
        };
        reader.onerror = () => {
          setSnackbar({ open: true, message: 'Failed to read error response.', severity: 'error' });
        };
        reader.readAsText(error.response.data);
      } else {
        setSnackbar({ open: true, message, severity: 'error' });
      }
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <Container maxWidth="lg">
      <Card>
        <CardContent>
          <Typography variant="h4" component="h1" gutterBottom>
            Stable Diffusion Inference
          </Typography>

          <Box sx={{ mt: 3 }}>
            <TextField
              fullWidth
              label="Prompt (e.g., 'a beautiful landscape painting')"
              variant="outlined"
              value={prompt}
              onChange={(e) => setPrompt(e.target.value)}
              disabled={isGenerating}
              multiline
              rows={3}
            />
          </Box>

          <Box sx={{ mt: 2 }}>
            <TextField
              fullWidth
              label="Negative Prompt (e.g., 'blurry, low quality')"
              variant="outlined"
              value={negativePrompt}
              onChange={(e) => setNegativePrompt(e.target.value)}
              disabled={isGenerating}
              multiline
              rows={2}
            />
          </Box>

          <Box sx={{ mt: 3, textAlign: 'center' }}>
            <Button
              variant="contained"
              color="primary"
              size="large"
              onClick={handleGenerateImage}
              disabled={isGenerating}
            >
              {isGenerating ? <CircularProgress size={24} color="inherit" /> : 'Generate Image'}
            </Button>
          </Box>

          {generatedImage && (
            <Box sx={{ mt: 4, textAlign: 'center' }}>
              <Typography variant="h6" gutterBottom>Generated Image</Typography>
              <Paper elevation={3} sx={{ display: 'inline-block' }}>
                <img src={generatedImage} alt="Generated by Stable Diffusion" style={{ maxWidth: '100%', borderRadius: '4px' }} />
              </Paper>
            </Box>
          )}
        </CardContent>
      </Card>

      {snackbar && (
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar(null)}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
        >
          <Alert onClose={() => setSnackbar(null)} severity={snackbar.severity} sx={{ width: '100%' }}>
            {snackbar.message}
          </Alert>
        </Snackbar>
      )}
    </Container>
  );
};

export default InferencePage;
